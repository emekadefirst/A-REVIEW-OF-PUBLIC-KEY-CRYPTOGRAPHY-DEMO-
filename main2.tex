\documentclass[12pt]{report}
%\usepackage{lmodern}
%\usepackage{scrextend}
%\changefontsizes[12pt]{12pt}
\usepackage[centertags]{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
	\usepackage{csquotes}
	\usepackage{newlfont}
	%\usepackage{rotating}
	%\usepackage{pdflscape}
	\usepackage{graphicx}
	\usepackage{epstopdf}
	\usepackage{multirow}
	%\usepackage{amsmath, amssymb, graphics}
	
	
	%\usepackage[active]{srcltx}  %SRC Specials for DVI search
	% Fuzz{ -------------------------------------------------------------------
		
		
		\hfuzz3pt % Don't bother to report over-full boxes if over-edge is < 2pt
		% Line spacing -----------------------------------------------------------
		\newlength{\defbaselineskip}
		\setlength{\defbaselineskip}{\baselineskip}
		\newcommand{\setlinespacing}[1]%
		{\setlength{\baselineskip}{#1 \defbaselineskip}}
		\newcommand{\doublespacing}{\setlength{\baselineskip}%
			{2.0 \defbaselineskip}}
		\newcommand{\singlespacing}{\setlength{\baselineskip}{\defbaselineskip}}
		% MATH -------------------------------------------------------------------
		\newcommand{\A}{{\cal A}}
		\newcommand{\h}{{\cal H}}
		\newcommand{\s}{{\cal S}}
		\newcommand{\W}{{\cal W}}
		\newcommand{\BH}{\mathbf B(\cal H)}
		\newcommand{\KH}{\cal  K(\cal H)}
		\newcommand{\Real}{\mathbb R}
		\newcommand{\Complex}{\mathbb C}
		\newcommand{\Field}{\mathbb F}
		\newcommand{\RPlus}{[0,\infty)}
		%
		\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
		\newcommand{\essnorm}[1]{\norm{#1}_{\text{\rm\normalshape ess}}}
		\newcommand{\abs}[1]{\left\vert#1\right\vert}
		\newcommand{\set}[1]{\left\{#1\right\}}
		\newcommand{\seq}[1]{\left<#1\right>}
		\newcommand{\eps}{\varepsilon}
		\newcommand{\To}{\longrightarrow}
		\newcommand{\RE}{\operatorname{Re}}
		\newcommand{\IM}{\operatorname{Im}}
		\newcommand{\Poly}{{\cal{P}}(E)}
		\newcommand{\EssD}{{\cal{D}}}
		% THEOREMS ---------------------------------------------------------------
		%\theoremstyle{plain}
		\newtheorem{thm}{Theorem}[section]
		\newtheorem{cor}[thm]{Corollary}
		\newtheorem{lem}[thm]{Lemma}
		\newtheorem{prop}[thm]{Proposition}
		%\theoremstyle{plain}
		\newtheorem{defn}{Definition}[section]
		%\theoremstyle{remark}
		\newtheorem{rem}{Remark}[section]
		%
		\renewcommand{\theequation}{\thesection.\arabic{equation}}
		
		\setcounter{secnumdepth}{3}
		
		\setlinespacing{9.5}%
		\usepackage[top= 1in, left= 1.2in, right= 1in, bottom= 1.3in]{geometry}
		%\numberwithin{equation}{section}
		\numberwithin{equation}{chapter}
		
		% \numberwithin{equation}{section}
		
		%\counterwithin{equation}{chapter}
		
		
          \begin{document} 
	       \fontsize{12}
           {20}\selectfont
			\begin{titlepage}
				\begin{center}
					\vspace*{3.5cm}
					\large{REVIEW OF PUBLIC KEY CRYPTOGRAPHY}\\
					\vspace{5cm}
					\large {CHIBUOGWU VICTOR CHUKWUEMEKA}\\
				\vspace{0.2cm}
				\small {200551029}\\
			\vspace{4cm}
             A PROJECT SUBMITTED TO DEPARTMENT OF MATHEMATICS,\\
             \vspace{0.2cm}
                FACULTY OF SCIENCE, LAGOS STATE UNIVERSITY,\\
                \vspace{0.2cm}
			IN PARTIAL FULFILMENT OF THE REQUIREMENT FOR THE AWARD OF
			\vspace{0.2cm}\\
			BACHELOR OF SCIENCE DEGREE (B.Sc HONS.) IN MATHEMATICS,
			\vspace{0.2cm}
			AT LAGOS STATE UNIVERSITY, OJO, LAGOS, NIGERIA\\
			\vspace{1cm}
			{SEPTEMBER, 2024}\\			
	\end{center}
	
\end{titlepage}



\newpage
\pagenumbering{roman}
\addcontentsline{toc}{section}{Certification}
\begin{flushleft}
	\textbf{\LARGE Certification}
\end{flushleft}
\vspace{1cm}
I certify that this project work with the title \emph{\large REVIEW OF PUBLIC KEY CRYPTOGRAPHY} submitted by CHIBUOGWU, VICTOR CHUKWUEMEKA with matriculation number \textbf{200551029} was carried out under my supervision in the Department of Mathematics, Faculty of science, Lagos State University, Ojo, Lagos.
\\	
\begin{flushleft}
	
	
	\vspace{1.5cm}
	.......................
	\hspace{7cm}
	..............................\\
	\textbf{Dr. AbdulKareem A.O.}\hspace {6.2cm} DATE\\
	Supervisor\\
	
	\vspace{1.5cm}
	
	.......................
	\hspace{7cm}
	..............................\\
	\textbf{Dr. Olutimo A.L.}\hspace{6cm} DATE\\
	Head of Mathematics Department\\
	\vspace{1.5cm}
	\vspace{1.5cm}\\
..............................................\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
..............................................\\
External Examiner
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,DATE
\end{flushleft}

\pagebreak
\addcontentsline{toc}{section}{Dedication}
\begin{center}
    \textbf{DEDICATION}
\end{center}
Dedicated to my family and friends for unwavering support. And to my teachers whose wisdom and guidance made this possible.



\pagebreak
\addcontentsline{toc}{section}{Acknowledgement}
\begin{center}
	\textbf{ACKNOWLEDGEMENT}
\end{center}

I would like to express my deepest gratitude to the current Head of the Mathematics Department at Lagos State University, Dr. Olutmimo A.L., and my advisor, Dr. AbdulKareem A.O., for their invaluable guidance and support throughout this research. I also thank my colleagues and friends for their encouragement and assistance. Special thanks to my family for their constant support and understanding.

\newpage

\pagebreak
\addcontentsline{toc}{section}{Abstract}
\begin{center}
	\textbf{ABSTRACT}
\end{center}

This work presents the use case of Public Key encryption, discussing in detail the models and methods for encryption and decryption. It also illustrates the algorithms of each method, providing examples to solve unconstrained problems.




\pagebreak
\addcontentsline{toc}{section}{Table of Contents}
\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{INTRODUCTION}

\section{Introduction to Public Key Cryptography}
Public Key Cryptography (PKC), introduced by Whitfield Diffie and Martin Hellman in 1976, revolutionized secure communication by addressing the challenge of key distribution. Unlike traditional symmetric key cryptography, PKC uses a pair of mathematically related keys: a public key for encryption and a private key for decryption. This dual-key system has enabled the development of secure communication protocols and digital signatures, among other applications.

\section{Background of the Study}
Since its inception, PKC has undergone significant development. Major algorithms like RSA (Rivest-Shamir-Adleman), DSA (Digital Signature Algorithm), and ECC (Elliptic Curve Cryptography) have been introduced to address various cryptographic challenges. These algorithms are characterized by their computational efficiency, security against attacks, and suitability for different applications. The security of PKC relies on the difficulty of mathematical problems such as factoring large integers or solving discrete logarithm problems in finite fields.

\section{Statement of Problem}
Despite its advantages, PKC faces several challenges:
\begin{itemize}
    \item \textbf{Key Management:} Generating, distributing, and storing keys securely.
    \item \textbf{Computational Efficiency:} Ensuring encryption and decryption operations are fast and scalable.
    \item \textbf{Vulnerabilities:} Addressing vulnerabilities such as side-channel attacks, quantum computing threats, and implementation errors.
\end{itemize}


\subsection{Aim and Objectives of the Study}
The primary aim of this study is to provide a comprehensive examination of public key cryptography from a mathematical perspective. The specific objectives include:
\begin{itemize}
    \item \textbf{Historical Development:} Tracing the historical development and evolution of public key cryptography.
    \item \textbf{Mathematical Principles:} Explaining the mathematical principles underlying key generation, encryption, and decryption.
    \item \textbf{Real-World Applications:} Evaluating the effectiveness of public key cryptographic systems in various real-world applications.
    \item \textbf{Security Analysis:} Identifying and analyzing major security threats and vulnerabilities associated with public key cryptography.
    \item \textbf{Future Directions:} Suggesting potential improvements and future research directions.
\end{itemize}

\section{Significance of the Study}
This study advances our understanding of the mathematical foundations of public key cryptography, provides insights into real-world applications and challenges, and guides policymakers in understanding and regulating cryptographic technologies.

\section{Scope of the Study}
The study comprehensively examines public key cryptography, including its theoretical foundations, development from inception to current technologies, real-world applications in secure communication, digital signatures, blockchain, and challenges such as key management and performance optimization. Future directions include post-quantum cryptography. Symmetric key cryptography is covered only for context or comparison.

\section{Definition of Terms}
\begin{itemize}
    \item \textbf{Public Key Cryptography (PKC):} A cryptographic system that uses two keys—a public key for encryption and a private key for decryption.
    \item \textbf{RSA (Rivest-Shamir-Adleman):} A widely used PKC algorithm based on the difficulty of factoring large integers.
    \item \textbf{Digital Signature:} A mathematical scheme for verifying the authenticity and integrity of digital messages or documents.
    \item \textbf{Elliptic Curve Cryptography (ECC):} A PKC algorithm based on the properties of elliptic curves over finite fields.
    \item \textbf{Key Exchange:} The process of securely exchanging cryptographic keys between parties.
\end{itemize}








\newpage
\pagenumbering{arabic}
\chapter{LITERATURE REVIEW}
\section{Mathematical Principles of Public Key Cryptography}
Public Key Cryptography is built upon several fundamental mathematical principles:
\begin{itemize}
    \item \textbf{Number Theory:} PKC algorithms rely on prime factorization and discrete logarithms.
    \item \textbf{Modular Arithmetic:} Modular arithmetic is used in PKC algorithms to perform operations within finite sets of integers.
    \item \textbf{Group Theory:} Group theory concepts like cyclic groups define cryptographic primitives.
    \item \textbf{Complexity Theory:} The security of PKC relies on computationally hard problems such as factoring large integers or solving discrete logarithm problems.
\end{itemize}

\section{RSA Algorithm: Example of Public Key Cryptography}

\subsection{Key Generation}
In RSA, each user generates a pair of keys: a public key and a private key. The public key consists of two components: the modulus \(n\) and the public exponent \(e\). The private key consists of \(n\) and the private exponent \(d\). The security of RSA is based on the difficulty of factoring the modulus \(n\) into its prime factors.

\subsection{Encryption and Decryption}
\begin{itemize}
    \item To encrypt a message \(m\), the sender uses the recipient’s public key \( (n, e) \) to compute \( c = m^e \mod n \).
    \item To decrypt the ciphertext \(c\), the recipient uses their private key \( (n, d) \) to compute \( m = c^d \mod n \).
\end{itemize}

\subsection{Example}
Encrypting \( M = 123 \):
\[
C = 123^{17} \mod 3233 = 855
\]
Decrypting \( C = 855 \):
\[
M = 855^{2753} \mod 3233 = 123
\]

\section{Elliptic Curve Cryptography (ECC)}

\subsection{Elliptic Curves}
ECC uses elliptic curves defined by the equation \( y^2 = x^3 + ax + b \) over finite fields. It offers equivalent security to RSA but with smaller key sizes, making it suitable for constrained environments such as mobile devices and IoT.

\subsection{Key Generation}
\begin{itemize}
    \item Select an elliptic curve \( E \) defined over a finite field \( F_p \).
    \item Choose a base point \( G \) on the curve \( E \) with a large prime order \( n \).
    \item Select a random integer \( d \) as the private key such that \( 1 < d < n - 1 \).
    \item Compute the public key \( Q = dG \), where \( G \) is the base point.
\end{itemize}

\subsection{Encryption and Decryption}
\begin{itemize}
    \item \textbf{Encryption:} To encrypt a message \( M \) (represented as a point on the curve), the sender computes the ciphertext pair \( (C_1, C_2) \), where \( C_1 = kG \) and \( C_2 = M + kQ \).
    \item \textbf{Decryption:} The recipient recovers the message \( M \) by computing \( M = C_2 - dC_1 \) using their private key \( d \).
\end{itemize}

\section{Pairing-Based Cryptography}

\subsection*{Definition}
Pairing is a bilinear map defined over elliptic curve subgroups. Let \( G_1 \), \( G_2 \), and \( G_T \) be groups of the same prime order \( q \). A bilinear map \( e: G_1 \times G_2 \to G_T \) satisfies the following properties:
\begin{itemize}
    \item \textbf{Bilinearity:} For all \( (S, T) \in G_1 \times G_2 \) and for all \( a, b \in \mathbb{Z} \), we have \( e(aS, bT) = e(S, T)^{ab} \).
    \item \textbf{Non-degeneracy:} \( e(S, T) = 1 \) for all \( T \in G_2 \) if and only if \( S = 1 \).
    \item \textbf{Computability:} For all \( (S, T) \in G_1 \times G_2 \), \( e(S, T) \) is efficiently computable.
\end{itemize}

\subsection*{Consequences of Pairings}
Pairings have important consequences on the hardness of certain variants of the Diffie-Hellman problem. For instance, symmetric pairings lead to a strict separation between the intractability of the computational Diffie-Hellman problem and the hardness of the corresponding decision problem.


\newpage
\chapter{Method of Study}

\section{RSA Cryptosystem}
The RSA cryptosystem is based on the difficulty of factoring large prime numbers. The steps for key generation, encryption, and decryption are described as follows:
\begin{itemize}
    \item Choose two distinct prime numbers \( p \) and \( q \).
    \item Compute \( N = pq \) and the totient \( \phi(N) = (p-1)(q-1) \).
    \item Choose an integer \( e \) such that \( 1 < e < \phi(N) \) and \( e \) is coprime with \( \phi(N) \).
    \item Compute \( d \) as the modular multiplicative inverse of \( e \mod \phi(N) \).
\end{itemize}
The public key is \( (e, N) \), and the private key is \( (d, N) \).

\section{Elliptic Curve Cryptography}
ECC is based on the algebraic structure of elliptic curves over finite fields. The security of ECC relies on the difficulty of the elliptic curve discrete logarithm problem.

\section{Mathematical Foundation of RSA}

The RSA algorithm relies on the difficulty of factoring large composite numbers. The key steps are outlined below.

\subsection*{Key Generation}
Given two large prime numbers \( p \) and \( q \), we compute:
\[
N = p \times q
\]
where \( N \) is the modulus. Next, calculate Euler's totient function:
\[
\phi(N) = (p - 1) \times (q - 1)
\]
Choose an integer \( e \) such that:
\[
1 < e < \phi(N) \quad \text{and} \quad \gcd(e, \phi(N)) = 1
\]
The public key is \( (N, e) \). To generate the private key, compute \( d \) as the modular inverse of \( e \) modulo \( \phi(N) \):
\[
d \times e \equiv 1 \mod \phi(N)
\]
The private key is \( (N, d) \).

\subsection*{Encryption}
Given a plaintext message \( M \), the ciphertext \( C \) is computed using the public key \( (N, e) \):
\[
C = M^e \mod N
\]

\subsection*{Decryption}
To decrypt the ciphertext \( C \), the recipient uses their private key \( (N, d) \) to recover the original message \( M \):
\[
M = C^d \mod N
\]

\subsection*{Example}
Let \( p = 61 \) and \( q = 53 \). First, compute:
\[
N = 61 \times 53 = 3233
\]
Next, calculate:
\[
\phi(N) = (61 - 1) \times (53 - 1) = 3120
\]
Choose \( e = 17 \), which is coprime to \( \phi(N) \). Now, compute \( d \), the modular inverse of \( 17 \mod 3120 \), which gives \( d = 2753 \).

For encryption, given \( M = 123 \), calculate:
\[
C = 123^{17} \mod 3233 = 855
\]
To decrypt, calculate:
\[
M = 855^{2753} \mod 3233 = 123
\]
Thus, the encryption and decryption process works as expected.


\section{Elliptic Curve Cryptography (ECC)}

ECC is based on the algebraic structure of elliptic curves over finite fields. The security of ECC relies on the difficulty of solving the elliptic curve discrete logarithm problem (ECDLP).

\subsection*{Elliptic Curve Definition}
An elliptic curve \( E \) over a finite field \( F_p \) is defined by the equation:
\[
y^2 = x^3 + ax + b \mod p
\]
where \( 4a^3 + 27b^2 \neq 0 \mod p \), ensuring the curve has no singularities.

\subsection*{Key Generation}
\begin{itemize}
    \item Select a finite field \( F_p \) and an elliptic curve \( E \) defined over \( F_p \).
    \item Choose a base point \( G \) on the curve \( E \) with large prime order \( n \).
    \item Select a random integer \( d \) (the private key) such that \( 1 < d < n-1 \).
    \item Compute the public key \( Q = d \times G \), where \( G \) is the base point on the curve.
\end{itemize}

\subsection*{Encryption}
To encrypt a message \( M \) (represented as a point on the curve), the sender chooses a random integer \( k \) and computes the ciphertext pair \( (C_1, C_2) \):
\[
C_1 = k \times G
\]
\[
C_2 = M + k \times Q
\]

\subsection*{Decryption}
To decrypt the ciphertext \( (C_1, C_2) \), the recipient uses their private key \( d \) to recover the original message:
\[
M = C_2 - d \times C_1
\]

\subsection*{Example}
Consider the elliptic curve \( y^2 = x^3 + x + 1 \) over \( F_{89} \), and let the base point be \( G = (2, 22) \). Suppose the private key is \( d = 10 \). The public key is:


\section{Pairing-Based Cryptography}

Pairing-based cryptography relies on bilinear maps, enabling applications like identity-based encryption.

\subsection*{Mathematical Definition of Pairing}
Let \( G_1 \) and \( G_2 \) be cyclic groups of prime order \( q \), and let \( G_T \) be a multiplicative group of the same order. A pairing is a bilinear map:
\[
e: G_1 \times G_2 \to G_T
\]
satisfying the following properties:
\begin{itemize}
    \item \textbf{Bilinearity:} For all \( P \in G_1 \), \( Q \in G_2 \), and \( a, b \in \mathbb{Z}_q \):
    \[
    e(aP, bQ) = e(P, Q)^{ab}
    \]
    \item \textbf{Non-degeneracy:} \( e(P, Q) = 1 \) if and only if \( P = 1 \) or \( Q = 1 \).
    \item \textbf{Computability:} The pairing \( e(P, Q) \) can be computed efficiently.
\end{itemize}

\subsection*{Example of Pairing}
Let \( P \in G_1 \) and \( Q \in G_2 \). The pairing \( e(P, Q) \) can be computed using Miller's algorithm or the Tate pairing, depending on the elliptic curve used.


\newpage
\chapter{IMPLEMENTATION}

\section{Introduction}

This chapter focuses on the practical implementation of the cryptographic algorithms discussed in the previous chapters, particularly RSA and Elliptic Curve Cryptography (ECC). The implementations will be demonstrated using Python, leveraging libraries such as \texttt{pycryptodome} for RSA and \texttt{ecdsa} for ECC. The source code for key generation, encryption, and decryption will be provided, along with explanations of each step.

\section{RSA Algorithm Implementation}

\subsubsection{RSA Key Generation}

In RSA, key generation is the process of creating a public-private key pair. The public key is used for encryption, while the private key is used for decryption. The security of RSA lies in the difficulty of factoring large composite numbers. Below is the Python implementation for generating RSA keys:

\begin{lstlisting}[language=Python]
from Crypto.PublicKey import RSA

# Generate RSA key pair
def generate_rsa_keys():
    key = RSA.generate(2048)  # Generate 2048-bit RSA key
    private_key = key.export_key()
    public_key = key.publickey().export_key()

    with open('private_key.pem', 'wb') as priv_file:
        priv_file.write(private_key)

    with open('public_key.pem', 'wb') as pub_file:
        pub_file.write(public_key)

    print("RSA Keys Generated and Saved.")
\end{lstlisting}

\subsection{RSA Encryption and Decryption}

The following code demonstrates how to encrypt and decrypt a message using the RSA keys. The message is first encrypted using the recipient’s public key and decrypted using the private key.

\begin{lstlisting}[language=Python]
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes

# RSA Encryption
def rsa_encrypt(message, public_key_path='public_key.pem'):
    with open(public_key_path, 'rb') as pub_file:
        public_key = RSA.import_key(pub_file.read())
    cipher_rsa = PKCS1_OAEP.new(public_key)
    encrypted_message = cipher_rsa.encrypt(message.encode('utf-8'))
    return encrypted_message

# RSA Decryption
def rsa_decrypt(encrypted_message, private_key_path='private_key.pem'):
    with open(private_key_path, 'rb') as priv_file:
        private_key = RSA.import_key(priv_file.read())
    cipher_rsa = PKCS1_OAEP.new(private_key)
    decrypted_message = cipher_rsa.decrypt(encrypted_message).decode('utf-8')
    return decrypted_message

# Example usage
message = "Public Key Cryptography is secure."
encrypted_msg = rsa_encrypt(message)
print(f"Encrypted: {encrypted_msg}")
decrypted_msg = rsa_decrypt(encrypted_msg)
print(f"Decrypted: {decrypted_msg}")
\end{lstlisting}

\subsection{Elliptic Curve Cryptography (ECC) Implementation}

Elliptic Curve Cryptography provides the same level of security as RSA but with much smaller key sizes, making it efficient for constrained environments. Below is an example implementation of ECC using the \texttt{ecdsa} library.

\subsection{ECC Key Generation}

ECC key generation involves choosing a private key (a random integer) and computing the corresponding public key, which is a point on the elliptic curve.

\begin{lstlisting}[language=Python]
from ecdsa import SigningKey, SECP256k1

# Generate ECC key pair
def generate_ecc_keys():
    private_key = SigningKey.generate(curve=SECP256k1)
    public_key = private_key.get_verifying_key()

    with open('ecc_private_key.pem', 'wb') as priv_file:
        priv_file.write(private_key.to_pem())

    with open('ecc_public_key.pem', 'wb') as pub_file:
        pub_file.write(public_key.to_pem())

    print("ECC Keys Generated and Saved.")
\end{lstlisting}

\subsection{ECC Encryption and Decryption}

While ECC is primarily used for digital signatures and key exchange, we can simulate encryption and decryption by signing and verifying a message.


from ecdsa import SigningKey, VerifyingKey, BadSignatureError

\section{Kannan-Type Fixed Point Theorem in b-Metric Spaces}
We present a generalization of the Kannan fixed point theorem to b-metric spaces. The classical Kannan fixed point theorem provides conditions for the existence of a unique fixed point for mappings that satisfy a specific contraction condition. We extend this result to b-metric spaces, which are more general than metric spaces and allow for a relaxed triangle inequality.

\subsection*{Kannan-Type Fixed Point Theorem}
Let $(X, d)$ be a complete b-metric space with constant $s \geq 1$, and let $T: X \to X$ be a mapping such that for all $x, y \in X$, the following condition holds:
\[
d(Tx, Ty) \leq \alpha [d(x, Tx) + d(y, Ty)]
\]
for some constant $\alpha \in [0, \frac{1}{2})$. Then $T$ has a unique fixed point, i.e., there exists a unique $x^* \in X$ such that $T(x^*) = x^*$.

\textbf{Proof}

\begin{enumerate}

\item\textbf{Constructing the Iterative Sequence}
Choose an arbitrary point $x_0 \in X$ and define a sequence $\{x_n\}$ by setting $x_{n+1} = T(x_n)$ for all $n \geq 0$. We will show that $\{x_n\}$ converges to a fixed point of $T$.

\item\textbf{Establishing a Distance Estimate}
Using the given contraction condition, we have:
\[
d(x_{n+1}, x_{n+2}) = d(Tx_n, Tx_{n+1}) \leq \alpha [d(x_n, Tx_n) + d(x_{n+1}, Tx_{n+1})].
\]
Since $\alpha < \frac{1}{2}$, we can derive that the sequence $\{x_n\}$ is contractive.

\item\textbf{Proving the Sequence is Cauchy}
We now show that $\{x_n\}$ is a Cauchy sequence. For any $m > n$, apply the relaxed triangle inequality to obtain:
\[
d(x_m, x_n) \leq s[d(x_m, x_{m-1}) + d(x_{m-1}, x_{m-2}) + \dots + d(x_{n+1}, x_n)].
\]
Using the contractive condition and summing the terms, we find that the series converges, implying that $\{x_n\}$ is a Cauchy sequence.

\item\textbf{Completeness and Convergence}
Since $(X, d)$ is a complete b-metric space, the Cauchy sequence $\{x_n\}$ converges to some $x^* \in X$.

\item\textbf{Verifying the Fixed Point}
By the continuity of $T$, taking the limit as $n \to \infty$ in $x_{n+1} = T(x_n)$ gives $x^* = T(x^*)$, so $x^*$ is a fixed point of $T$.

\item\textbf{Uniqueness of the Fixed Point}
Suppose $y^* \in X$ is another fixed point such that $T(y^*) = y^*$. Using the contractive condition for $x^*$ and $y^*$, we get:
\[
d(x^*, y^*) = d(Tx^*, Ty^*) \leq \alpha [d(x^*, Tx^*) + d(y^*, Ty^*)] = \alpha [d(x^*, x^*) + d(y^*, y^*)] = 0,
\]
which implies $x^* = y^*$. Thus, the fixed point is unique.
\end{enumerate}




\newpage
\chapter{SUMMARY}
\section{Summary}

This project explores the applications of cryptographic techniques, specifically RSA and Elliptic Curve Cryptography (ECC), in secure communication. The project examines the theoretical foundations of RSA and ECC and investigates their real-world applications, highlighting RSA's role in securing web traffic through SSL/TLS, authenticating sender identities via digital signatures (PGP), and validating software updates. Additionally, the project discusses ECC's efficiency benefits in mobile devices, IoT devices, smart cards, and cryptocurrency (Bitcoin, blockchain). The project demonstrates the significance of cryptographic techniques in ensuring secure communication and provides insights into their practical applications. Overall, the project showcases the importance of RSA and ECC in maintaining secure communication in various industries and technologies.


\newpage
\section{Conclusion}
This study has provided an in-depth exploration of RSA, Elliptic Curve Cryptography (ECC), and Pairing-Based Cryptography. Each method was explored mathematically with examples provided to illustrate their applications in cryptography. These methods play critical roles in ensuring the security and privacy of digital communications, and understanding their mathematical foundations is essential for implementing secure cryptographic systems., making it applicable to a broader class of problems.

\newpage
\addcontentsline{toc}{section}{REFERENCES}
\textbf{\LARGE{References}} 

\bibitem{diffie1976}
Diffie, W., \& Hellman, M. (1976). 
\textit{New Directions in Cryptography}. 
IEEE Transactions on Information Theory, 22(6), 644-654.

\bibitem{kannan1969}
Kannan, R. (1969). 
\textit{Some Results on Fixed Points}. 
Bulletin of the Calcutta Mathematical Society, 61(1), 71-76.

\bibitem{rivest1978}
Rivest, R. L., Shamir, A., \& Adleman, L. (1978). 
\textit{A Method for Obtaining Digital Signatures and Public-Key Cryptosystems}. 
Communications of the ACM, 21(2), 120-126. 
 \begin{enumerate}

\end{document}